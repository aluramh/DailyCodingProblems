from typing import List


class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        # This will work like a "visited" matrix
        lands = {}
        count = 0

        def is_inside_bounds(grid, x, y):
            firstRow = grid[0]
            is_inside = x >= 0 and y >= 0 and x < len(grid) and y < len(
                firstRow)
            return is_inside

        def findLand(grid, lands, x, y):
            # Recursively traverse the neighbors until there are no more neighbors to traverse.
            # Mark them as visited and return 1 when finished.
            steps = [(1, 0), (0, 1), (-1, 0), (0, -1)]

            for dx, dy in steps:
                new_x = x + dx
                new_y = y + dy
                key = f"{new_x}-{new_y}"

                if is_inside_bounds(grid, new_x,
                                    new_y) and grid[new_x][new_y] == "1":
                    if not key in lands:
                        # mark as visited so we don't do it in the future
                        lands[key] = True
                        findLand(grid, lands, new_x, new_y)

            # after visiting all the neighbors, return 1 since this x,y has been fully visited
            lands[f"{x}{y}"] = True
            return 1

        # Loop through all the grid items
        for i, row in enumerate(grid):
            for j, col in enumerate(row):
                if grid[i][j] == "1":
                    key = f"{i}-{j}"

                    if not (key in lands):
                        found_land = findLand(grid, lands, i, j)
                        count += found_land

        # print(lands)
        return count


tests = [
    (
        [
            ["1", "1", "1", "1", "0"],
            ["1", "1", "0", "1", "0"],
            ["1", "1", "0", "0", "0"],
            ["0", "0", "0", "0", "0"],
        ],
        1,
    ),
    (
        [
            [
                "1", "0", "0", "1", "1", "1", "0", "1", "1", "0", "0", "0",
                "0", "0", "0", "0", "0", "0", "0", "0"
            ],
            [
                "1", "0", "0", "1", "1", "0", "0", "1", "0", "0", "0", "1",
                "0", "1", "0", "1", "0", "0", "1", "0"
            ],
            [
                "0", "0", "0", "1", "1", "1", "1", "0", "1", "0", "1", "1",
                "0", "0", "0", "0", "1", "0", "1", "0"
            ],
            [
                "0", "0", "0", "1", "1", "0", "0", "1", "0", "0", "0", "1",
                "1", "1", "0", "0", "1", "0", "0", "1"
            ],
            [
                "0", "0", "0", "0", "0", "0", "0", "1", "1", "1", "0", "0",
                "0", "0", "0", "0", "0", "0", "0", "0"
            ],
            [
                "1", "0", "0", "0", "0", "1", "0", "1", "0", "1", "1", "0",
                "0", "0", "0", "0", "0", "1", "0", "1"
            ],
            [
                "0", "0", "0", "1", "0", "0", "0", "1", "0", "1", "0", "1",
                "0", "1", "0", "1", "0", "1", "0", "1"
            ],
            [
                "0", "0", "0", "1", "0", "1", "0", "0", "1", "1", "0", "1",
                "0", "1", "1", "0", "1", "1", "1", "0"
            ],
            [
                "0", "0", "0", "0", "1", "0", "0", "1", "1", "0", "0", "0",
                "0", "1", "0", "0", "0", "1", "0", "1"
            ],
            [
                "0", "0", "1", "0", "0", "1", "0", "0", "0", "0", "0", "1",
                "0", "0", "1", "0", "0", "0", "1", "0"
            ],
            [
                "1", "0", "0", "1", "0", "0", "0", "0", "0", "0", "0", "1",
                "0", "0", "1", "0", "1", "0", "1", "0"
            ],
            [
                "0", "1", "0", "0", "0", "1", "0", "1", "0", "1", "1", "0",
                "1", "1", "1", "0", "1", "1", "0", "0"
            ],
            [
                "1", "1", "0", "1", "0", "0", "0", "0", "1", "0", "0", "0",
                "0", "0", "0", "1", "0", "0", "0", "1"
            ],
            [
                "0", "1", "0", "0", "1", "1", "1", "0", "0", "0", "1", "1",
                "1", "1", "1", "0", "1", "0", "0", "0"
            ],
            [
                "0", "0", "1", "1", "1", "0", "0", "0", "1", "1", "0", "0",
                "0", "1", "0", "1", "0", "0", "0", "0"
            ],
            [
                "1", "0", "0", "1", "0", "1", "0", "0", "0", "0", "1", "0",
                "0", "0", "1", "0", "1", "0", "1", "1"
            ],
            [
                "1", "0", "1", "0", "0", "0", "0", "0", "0", "1", "0", "0",
                "0", "1", "0", "1", "0", "0", "0", "0"
            ],
            [
                "0", "1", "1", "0", "0", "0", "1", "1", "1", "0", "1", "0",
                "1", "0", "1", "1", "1", "1", "0", "0"
            ],
            [
                "0", "1", "0", "0", "0", "0", "1", "1", "0", "0", "1", "0",
                "1", "0", "0", "1", "0", "0", "1", "1"
            ],
            [
                "0", "0", "0", "0", "0", "0", "1", "1", "1", "1", "0", "1",
                "0", "0", "0", "1", "1", "0", "0", "0"
            ],
        ],
        58,
    ),
    (
        [
            ["1", "1", "0", "0", "0"],
            ["1", "1", "0", "0", "0"],
            ["0", "0", "1", "0", "0"],
            ["0", "0", "0", "1", "1"],
        ],
        3,
    ),
]

try:
    for (grid, expected) in tests:
        r = Solution().numIslands(grid)
        print(f"Expected: {expected}. Computed: {r}")
        assert (r == expected)
except AssertionError:
    print("Error!")
